### 在Java中，final关键字可以用来修饰数据、方法、参数、类。

##### 1. 修饰数据

> 在编写程序时，我们经常需要说明一个数据是不可变的，我们称为常量。在java中，用final关键字修饰的变量，只能进行一次赋值操作，并且在生存期内不可以改变它的值。更重要的是，final会告诉编译器，这个数据是不会修改的，那么编译器就可能会在编译时期就对该数据进行替换甚至执行计算，这样可以对我们的程序起到一点优化。不过在针对基本类型和引用类型时，final关键字的效果存在细微差别。

    class Value {
      int v;
      public Value(int v) {
        this.v = v;
      }
    }

    public class FinalTest {
      final int f1 = 1;
      final int f2;
      public FinalTest() {
        f2 = 2;
      }

      public static void main(String[] args) {
        final int value1 = 1;
        // value1 = 4;
        final double value2;
        value2 = 2.0;
        final Value value3 = new Value(1);
        value3.v = 4;
      }
    }
> 上面的例子中，我们先来看一下main方法中的几个final修饰的数据，在给value1赋初始值之后，我们无法再对value1的值进行修改，final关键字起到了常量的作用。从value2我们可以看到，final修饰的变量可以不在声明时赋值，即可以先声明，后赋值。value3时一个引用变量，这里我们可以看到final修饰引用变量时，只是限定了引用变量的引用不可改变，即不能将value3再次引用另一个Value对象，但是引用的对象的值是可以改变的，从内存模型中我们看的更加清晰：



>上面的例子中，我们知道引用变量的值实际上是它所引用的对象的地址，也就是说该地址的值是不可改变的，从而说明了为什么引用变量不可以改变引用对象。而实际引用的对象实际上是不受final关键字的影响的，所以它的值是可以改变的。

>另一方面，我们看到了用final修饰成员变量时的细微差别，因为final修饰的数据的值是不可改变的，所以我们必须确保在使用前就已经对成员变量赋值了。因此对于final修饰的成员变量，我们有且只有两个地方可以给它赋值，一个是声明该成员时赋值，另一个是在构造方法中赋值，在这两个地方我们必须给它们赋初始值。

> 无论属性是基本类型还是引用类型，final所起的作用都是变量里面存放的“值”不能变。
这个值，对于基本类型来说，变量里面放的就是实实在在的值，如1，“abc”等。而引用类型变量里面放的是个地址，所以用final修饰引用类型变量指的是它里面的地址不能变，并不是说这个地址所指向的对象或数组的内容不可以变，这个一定要注意。
例如：类中有一个属性是final Person p=new Person("name")； 那么你**不能对p进行重新赋值，但是可以改变p里面属性的值，**p.setName('newName');
final修饰属性，声明变量时可以不赋值，而且一旦赋值就不能被修改了。对final属性可以在三个地方赋值：**声明时、初始化块中、构造方法中。**总之一定要赋值。

> 简单总结：**对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。**

>最后我们需要注意的一点是，同时使用static和final修饰的成员在内存中只占据一段不能改变的存储空间。

##### 2. 修饰方法参数
> 前面我们可以看到，如果变量是我们自己创建的，那么使用final修饰表示我们只会给它赋值一次且不会改变变量的值。那么如果变量是作为参数传入的，我们怎么保证它的值不会改变呢？这就用到了final的第二种用法，即在我们编写方法时，可以在参数前面添加final关键字，它表示在整个方法中，我们不会（实际上是不能）改变参数的值：

    public class FinalTest {
      /* ... */
      public void finalFunc(final int i, final Value value) {
        // i = 5; 不能改变i的值
        // v = new Value(); 不能改变v的值
        value.v = 5; // 可以改变引用对象的值
      }
    }
##### 3. 修饰方法
> 第三种方式，即用final关键字修饰方法，它表示该方法不能被覆盖。这种使用方式主要是从设计的角度考虑，即明确告诉其他可能会继承该类的程序员，不希望他们去覆盖这个方法。**可以被继承，但继承后不能被重写。**这种方式我们很容易理解，然而，关于private和final关键字还有一点联系，这就是**类中所有的private方法都隐式地指定为是final的**，由于无法在类外使用private方法，所以也就无法覆盖它。

>下面这段话摘自《Java编程思想》第四版第143页：

>　　“使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升。在最近的Java版本中，**不需要使用final方法进行这些优化了。**“

>　　**因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。**

##### 4. 修饰类
> 了解了final关键字的其他用法，我们很容易可以想到使用final关键字修饰类的作用，那就是用final修饰的类是无法被继承的。

> 上面我们讲解了final的四种用法，然而，对于第三种和第四种用法，我们却甚少使用。这不是没有道理的，从final的设计来讲，这两种用法甚至可以说是鸡肋，因为对于开发人员来讲，如果我们写的类被继承的越多，就说明我们写的类越有价值，越成功。即使是从设计的角度来讲，也没有必要将一个类设计为不可继承的。Java标准库就是一个很好的反例，特别是Java 1.0/1.1中Vector类被如此广泛的运用，如果所有的方法均未被指定为final的话，它可能会更加有用。如此有用的类，我们很容易想到去继承和重写他们，然而，由于final的作用，导致我们对Vector类的扩展受到了一些阻碍，导致了Vector并没有完全发挥它应有的全部价值。

> **在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。**

***

### 总结

>final关键字是我们经常使用的关键字之一，它的用法有很多，但是并不是每一种用法都值得我们去广泛使用。它的主要用法有以下四种：

1. 用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值；
2. 用来修饰方法参数，表示在变量的生存期中它的值不能被改变；
3. 修饰方法，表示该方法无法被重写；
4. 修饰类，表示该类无法被继承。

> 上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。

#### final关键字的好处

>下面总结了一些使用final关键字的好处:

>1. final关键字提高了性能。JVM和Java应用都会缓存final变量。
>2. final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。
>3. 使用final关键字，JVM会对方法、变量及类进行优化。

#### 不可变类

>创建不可变类要使用final关键字。不可变类是指它的对象一旦被创建了就不能被更改了。String是不可变类的代表。不可变类有很多好处，譬如它们的对象是只读的，可以在多线程环境下安全的共享，不用额外的同步开销等等。

#### 关于final的重要知识点

>1. final关键字可以用于成员变量、本地变量、方法以及类。
>2. final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。
>3. 你不能够对final变量再次赋值。
>4. 本地变量必须在声明时赋值。
>5. 在匿名类中所有变量都必须是final变量。
>6. final方法不能被重写。
>7. final类不能被继承。
>8. final关键字不同于finally关键字，后者用于异常处理。
>9. final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。
>10. 接口中声明的所有变量本身是final的。
>11. final和abstract这两个关键字是反相关的，final类就不可能是abstract的。
>12. final方法在编译阶段绑定，称为静态绑定(static binding)。
>13. 没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。
>14. 将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。
>15. 按照Java代码惯例，final变量就是常量，而且通常常量名要大写：
>16. 对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容。譬如：

#### final 的意义在哪里呢？
>其实对方法参数加final和方法内变量加上final的作用是相同的，即为了将它们传给内部类时保证**调用的一致性**
